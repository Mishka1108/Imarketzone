// src/app/messages-modal/messages-modal.component.ts - FULLY FIXED REAL-TIME

import { Component, OnInit, OnDestroy, Inject, ViewChild, ElementRef, AfterViewChecked, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatTabsModule } from '@angular/material/tabs';
import { MatListModule } from '@angular/material/list';
import { MatBadgeModule } from '@angular/material/badge';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MessageService } from '../services/message.service';
import { SocketService } from '../services/socket.service';
import { Message, Conversation } from '../models/message.model';
import { ProfileImageService } from '../services/profileImage.service';
import { Subject, takeUntil } from 'rxjs';
import { TranslateModule } from '@ngx-translate/core';

export interface MessagesModalData {
  userId: string;
  userName?: string;
}

@Component({
  selector: 'app-messages-modal',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    MatDialogModule,
    MatButtonModule,
    MatInputModule,
    MatFormFieldModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatTabsModule,
    MatListModule,
    MatBadgeModule,
    MatTooltipModule,
    TranslateModule
  ],
  templateUrl: './messages-modal.component.html',
  styleUrls: ['./messages-modal.component.scss']
})
export class MessagesModalComponent implements OnInit, OnDestroy, AfterViewChecked {
  @ViewChild('messagesContainer') private messagesContainer?: ElementRef;
  
  conversations: Conversation[] = [];
  selectedConversation: Conversation | null = null;
  messages: Message[] = [];
  newMessage: string = '';
  isMobile: boolean = false;
  isLoadingConversations: boolean = false;
  isLoadingMessages: boolean = false;
  isSending: boolean = false;
  isTyping: boolean = false;
  typingUserId: string | null = null;
  
  private destroy$ = new Subject<void>();
  private typingTimeout: any;
  private shouldScrollToBottom = false;

  constructor(
    public dialogRef: MatDialogRef<MessagesModalComponent>,
    @Inject(MAT_DIALOG_DATA) public data: MessagesModalData,
    private messageService: MessageService,
    private socketService: SocketService,
    private snackBar: MatSnackBar,
    private profileImageService: ProfileImageService,
    private cdr: ChangeDetectorRef // ‚úÖ ·Éì·Éê·Éî·Éõ·Éê·É¢·Éê ChangeDetectorRef
  ) {
    console.log('üí¨ Messages Modal Data:', this.data);
  }

  ngOnInit(): void {
    if (!this.data.userId) {
      const userId = localStorage.getItem('userId');
      if (userId) {
        this.data.userId = userId;
        console.log('‚úÖ Set userId from localStorage:', userId);
      } else {
        console.error('‚ùå No userId available!');
        this.showSnackBar('·Éê·Éï·É¢·Éù·É†·Éò·Éñ·Éê·É™·Éò·Éê ·É°·Éê·É≠·Éò·É†·Éù·Éê', 'error');
        this.close();
        return;
      }
    }

    this.checkIfMobile();
    this.setupSocketConnection();
    this.listenToSocketEvents();
    this.loadConversations();
  }

  ngAfterViewChecked(): void {
    if (this.shouldScrollToBottom) {
      this.scrollToBottom();
      this.shouldScrollToBottom = false;
    }
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
    
    // ‚úÖ ·Éí·Éê·É°·É£·É§·Éó·Éê·Éï·Éî·Éë·Éê
    if (this.typingTimeout) {
      clearTimeout(this.typingTimeout);
    }
  }

  private setupSocketConnection(): void {
    if (!this.socketService.isConnected()) {
      console.log('üîå Connecting to Socket.IO...');
      this.socketService.connect(this.data.userId);
    } else {
      console.log('‚úÖ Already connected to Socket.IO');
    }
  }

  private listenToSocketEvents(): void {
    console.log('üëÇ Setting up socket event listeners...');

    // ‚úÖ 1. ·Éê·ÉÆ·Éê·Éö·Éò ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éò·É° ·Éõ·Éù·É°·Éõ·Éî·Éú·Éê
    this.socketService.onNewMessage()
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        console.log('üì© Raw socket data received:', data);
        
        if (!data || !data.message) {
          console.warn('‚ö†Ô∏è Invalid message data received');
          return;
        }

        const msg = data.message;
        const senderId = this.extractUserId(msg.senderId);
        const receiverId = this.extractUserId(msg.receiverId);
        
        console.log('üì© Processing message:', {
          content: msg.content,
          from: senderId,
          to: receiverId,
          isMyMessage: senderId === this.data.userId
        });

        // ‚úÖ ·Éó·É£ ·Éê·É†·É©·Éî·É£·Éö·Éò ·É°·Éê·É£·Éë·Éê·É†·Éò·Éê ·É¶·Éò·Éê
        if (this.selectedConversation) {
          const otherUserId = this.extractUserId(this.selectedConversation.otherUser);
          
          // ·É®·Éî·Éï·Éê·Éõ·Éù·É¨·Éõ·Éù·Éó ·Éê·É†·Éò·É° ·Éó·É£ ·Éê·É†·Éê ·Éî·É° ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éê ·Éõ·Éò·Éõ·Éì·Éò·Éú·Éê·É†·Éî ·É°·Éê·É£·Éë·É†·Éò·Éì·Éê·Éú
          const isInCurrentConversation = 
            (senderId === otherUserId && receiverId === this.data.userId) ||
            (receiverId === otherUserId && senderId === this.data.userId);
          
          if (isInCurrentConversation) {
            console.log('‚úÖ Message belongs to current conversation');
            
            // ·É®·Éî·Éï·Éê·Éõ·Éù·É¨·Éõ·Éù·Éó ·Éê·É†·É°·Éî·Éë·Éù·Éë·É° ·Éó·É£ ·Éê·É†·Éê ·É£·Éô·Éï·Éî
            const messageId = msg._id || msg.id;
            const exists = this.messages.some(m => 
              (m._id === messageId || m.id === messageId)
            );
            
            if (!exists) {
              console.log('‚ûï Adding new message to UI:', msg.content);
              this.messages.push(msg);
              
              // ‚úÖ CRITICAL: ·Éï·Éê·É§·Éù·É†·É°·Éî·Éë·Éó UI ·Éí·Éê·Éú·Éê·ÉÆ·Éö·Éî·Éë·Éê·É°
              this.cdr.detectChanges();
              this.shouldScrollToBottom = true;
              
              // Mark as read if incoming message
              if (senderId === otherUserId) {
                setTimeout(() => {
                  this.markAsRead(this.selectedConversation!);
                }, 500);
              }
            } else {
              console.log('‚ÑπÔ∏è Message already exists in UI');
            }
          } else {
            console.log('‚ÑπÔ∏è Message is from another conversation');
          }
        }
        
        // ‚úÖ 2. ·É°·Éê·É£·Éë·É†·Éî·Éë·Éò·É° ·É°·Éò·Éò·É° ·Éí·Éê·Éú·Éê·ÉÆ·Éö·Éî·Éë·Éê
        this.updateConversationInList(msg, senderId, receiverId);
      });

    // ‚úÖ ·Éí·Éê·Éí·Éñ·Éê·Éï·Éú·Éò·Éö·Éò ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éò·É° ·Éì·Éê·Éì·Éê·É°·É¢·É£·É†·Éî·Éë·Éê
    this.socketService.onMessageSent()
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        if (data && data.message) {
          console.log('‚úÖ Message sent confirmation:', data.message.content);
        }
      });

    // ‚úÖ ·É°·Éê·É£·Éë·É†·Éò·É° ·Éí·Éê·Éú·Éê·ÉÆ·Éö·Éî·Éë·Éê
    this.socketService.onConversationUpdate()
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        console.log('üîÑ Conversation update received');
        this.loadConversations(true);
      });

    // ‚úÖ ·É¨·Éê·Éô·Éò·Éó·ÉÆ·É£·Éö·Éò ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò
    this.socketService.onMessagesRead()
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        if (data) {
          console.log('üìñ Messages were read');
          
          this.messages.forEach(msg => {
            const msgSenderId = this.extractUserId(msg.senderId);
            if (msgSenderId === this.data.userId) {
              msg.read = true;
            }
          });
          
          this.cdr.detectChanges();
        }
      });

    // ‚úÖ Typing indicators
    this.socketService.onTypingStart()
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        if (data && this.selectedConversation) {
          const otherUserId = this.extractUserId(this.selectedConversation.otherUser);
          
          if (data.userId === otherUserId) {
            console.log('‚úçÔ∏è User is typing:', data.userId);
            this.isTyping = true;
            this.typingUserId = data.userId;
            this.cdr.detectChanges();
          }
        }
      });

    this.socketService.onTypingStop()
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        if (data && this.selectedConversation) {
          const otherUserId = this.extractUserId(this.selectedConversation.otherUser);
          
          if (data.userId === otherUserId) {
            console.log('‚úã User stopped typing');
            this.isTyping = false;
            this.typingUserId = null;
            this.cdr.detectChanges();
          }
        }
      });

    // ‚úÖ ·Éô·Éê·Éï·É®·Éò·É†·Éò·É° ·É°·É¢·Éê·É¢·É£·É°·Éò
    this.socketService.getConnectionStatus()
      .pipe(takeUntil(this.destroy$))
      .subscribe((connected) => {
        console.log('üîå Socket connection status:', connected);
        if (!connected) {
          console.log('‚ö†Ô∏è Socket disconnected, attempting to reconnect...');
        }
      });
  }

  // ‚úÖ Helper method to extract user ID
  private extractUserId(user: any): string {
    if (!user) return '';
    if (typeof user === 'string') return user;
    return user._id || user.id || '';
  }

  // ‚úÖ ·Éí·Éê·Éú·Éê·ÉÆ·Éö·Éî·Éë·É£·Éö·Éò ·Éõ·Éî·Éó·Éù·Éì·Éò ·É°·Éê·É£·Éë·É†·Éî·Éë·Éò·É° ·É°·Éò·Éò·É° ·Éí·Éê·Éú·Éê·ÉÆ·Éö·Éî·Éë·Éò·É°·Éó·Éï·Éò·É°
  private updateConversationInList(message: Message, senderId: string, receiverId: string): void {
    console.log('üîÑ Updating conversations list');
    
    // ·Éí·Éê·Éú·Éï·É°·Éê·Éñ·É¶·Éï·É†·Éù·Éó "·Éõ·Éî·Éù·É†·Éî ·Éõ·Éù·Éõ·ÉÆ·Éõ·Éê·É†·Éî·Éë·Éî·Éö·Éò"
    const otherUserId = (senderId === this.data.userId) ? receiverId : senderId;
    
    // ·Éï·Éî·É´·Éî·Éë·Éó ·Éê·É†·É°·Éî·Éë·É£·Éö ·É°·Éê·É£·Éë·Éê·É†·É°
    const conversationIndex = this.conversations.findIndex(c => {
      const convOtherUserId = this.extractUserId(c.otherUser);
      return convOtherUserId === otherUserId;
    });

    if (conversationIndex !== -1) {
      // ·Éï·Éê·Éê·ÉÆ·Éö·Éî·Éë·Éó ·Éê·É†·É°·Éî·Éë·É£·Éö ·É°·Éê·É£·Éë·Éê·É†·É°
      const conversation = this.conversations[conversationIndex];
      conversation.lastMessage = message;
      conversation.updatedAt = message.createdAt;
      
      // Unread count - ·Éõ·ÉÆ·Éù·Éö·Éù·Éì ·Éó·É£ ·Éê·É† ·Éê·É†·Éò·É° ·Éê·É†·É©·Éî·É£·Éö·Éò ·Éì·Éê ·Éê·É† ·Éê·É†·Éò·É° ·É©·Éî·Éõ·Éò ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éê
      const isSelected = this.selectedConversation && 
        ((this.selectedConversation._id === conversation._id) || 
         (this.selectedConversation.id === conversation.id));
      
      const isOwnMessage = senderId === this.data.userId;
      
      if (!isSelected && !isOwnMessage) {
        conversation.unreadCount = (conversation.unreadCount || 0) + 1;
      }
      
      // ·Éí·Éê·Éì·Éê·Éï·Éò·É¢·Éê·Éú·Éù·Éó ·Éó·Éê·Éï·É®·Éò
      this.conversations.splice(conversationIndex, 1);
      this.conversations.unshift(conversation);
      
      console.log('‚úÖ Conversation updated and moved to top');
    } else {
      // ·Éê·ÉÆ·Éê·Éö·Éò ·É°·Éê·É£·Éë·Éê·É†·Éò - ·É©·Éê·Éï·É¢·Éï·Éò·É†·Éó·Éù·Éó ·Éó·Éê·Éï·Éò·Éì·Éê·Éú
      console.log('üÜï New conversation, reloading list');
      this.loadConversations(true);
    }
    
    // ‚úÖ Force UI update
    this.cdr.detectChanges();
  }

  checkIfMobile() {
    this.isMobile = window.innerWidth <= 768;
  }

  backToConversations() {
    this.selectedConversation = null;
    this.messages = [];
  }

  getMessageSenderAvatar(message: Message): string {
    if (!this.isOwnMessage(message)) {
      if (typeof message.senderId === 'object' && message.senderId !== null) {
        const sender = message.senderId as any;
        if (sender.avatar && sender.avatar.trim() !== '') {
          return sender.avatar;
        }
      }
      if (this.selectedConversation?.otherUser?.avatar) {
        return this.selectedConversation.otherUser.avatar;
      }
    }
    
    return this.profileImageService.getDefaultAvatar();
  }

  onAvatarError(event: Event): void {
    const img = event.target as HTMLImageElement;
    if (img && !img.dataset['errorHandled']) {
      img.src = this.profileImageService.getDefaultAvatar();
      img.dataset['errorHandled'] = 'true';
    }
  }

  loadConversations(silent: boolean = false): void {
    if (!silent) {
      console.log('üì• Loading conversations...');
      this.isLoadingConversations = true;
    }
    
    this.messageService.getConversations()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (conversations) => {
          if (!silent) {
            console.log('‚úÖ Loaded conversations:', conversations.length);
          }
          
          const oldSelectedId = this.selectedConversation?._id || this.selectedConversation?.id;
          
          this.conversations = conversations;
          this.isLoadingConversations = false;
          
          // Restore selected conversation
          if (oldSelectedId) {
            const stillExists = conversations.find(c => 
              (c._id === oldSelectedId || c.id === oldSelectedId)
            );
            if (stillExists) {
              this.selectedConversation = stillExists;
            }
          } else if (this.conversations.length > 0 && !this.selectedConversation) {
            this.selectConversation(this.conversations[0]);
          }
          
          this.cdr.detectChanges();
        },
        error: (error) => {
          console.error('‚ùå Failed to load conversations:', error);
          this.isLoadingConversations = false;
          if (!silent) {
            this.showSnackBar('·É°·Éê·É£·Éë·É†·Éî·Éë·Éò·É° ·É©·Éê·É¢·Éï·Éò·É†·Éó·Éï·Éê ·Éï·Éî·É† ·Éõ·Éù·ÉÆ·Éî·É†·ÉÆ·Éì·Éê', 'error');
          }
        }
      });
  }

  selectConversation(conversation: Conversation): void {
    console.log('üîç Selected conversation:', conversation.otherUser?.name);
    this.selectedConversation = conversation;
    this.messages = []; // ‚úÖ ·Éí·Éê·Éï·Éê·É°·É£·É§·Éó·Éê·Éï·Éù·Éó ·É´·Éï·Éî·Éö·Éò ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò
    this.loadMessages(conversation);
  }

  loadMessages(conversation: Conversation, silent: boolean = false): void {
    const otherUserId = this.extractUserId(conversation.otherUser);
    
    if (!otherUserId) {
      console.error('‚ùå No other user ID in conversation');
      return;
    }

    if (!silent) {
      this.isLoadingMessages = true;
    }
    
    this.messageService
      .getConversationMessages(this.data.userId, otherUserId)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (messages) => {
          console.log('‚úÖ Loaded', messages.length, 'messages');
          
          this.messages = messages;
          this.isLoadingMessages = false;
          
          // ‚úÖ Force change detection
          this.cdr.detectChanges();
          
          // Multiple scroll attempts for reliability
          setTimeout(() => this.scrollToBottom(), 0);
          setTimeout(() => this.scrollToBottom(), 100);
          setTimeout(() => this.scrollToBottom(), 300);
          
          this.markAsRead(conversation);
        },
        error: (error) => {
          console.error('‚ùå Failed to load messages:', error);
          this.isLoadingMessages = false;
          if (!silent) {
            this.showSnackBar('·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò·É° ·É©·Éê·É¢·Éï·Éò·É†·Éó·Éï·Éê ·Éï·Éî·É† ·Éõ·Éù·ÉÆ·Éî·É†·ÉÆ·Éì·Éê', 'error');
          }
        }
      });
  }

  markAsRead(conversation: Conversation): void {
    const otherUserId = this.extractUserId(conversation.otherUser);
    if (!otherUserId) return;

    this.messageService
      .markAsRead(this.data.userId, otherUserId)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: () => {
          console.log('‚úÖ Messages marked as read');
          if (this.selectedConversation) {
            this.selectedConversation.unreadCount = 0;
          }
          const conv = this.conversations.find(c => 
            (c._id === conversation._id || c.id === conversation.id)
          );
          if (conv) {
            conv.unreadCount = 0;
          }
          this.cdr.detectChanges();
        },
        error: (err) => console.error('‚ùå Failed to mark as read:', err)
      });
  }

  sendMessage(): void {
    const messageContent = this.newMessage.trim();
    
    if (!messageContent) {
      this.showSnackBar('·É®·Éî·Éò·Éß·Éï·Éê·Éú·Éî·Éó ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éê', 'error');
      return;
    }

    if (!this.selectedConversation?.otherUser) {
      this.showSnackBar('·Éê·Éò·É†·É©·Éò·Éî·Éó ·É°·Éê·É£·Éë·Éê·É†·Éò', 'error');
      return;
    }

    const receiverId = this.extractUserId(this.selectedConversation.otherUser);
    if (!receiverId) {
      this.showSnackBar('·É®·Éî·É™·Éì·Éù·Éõ·Éê: ·Éõ·Éò·Éõ·É¶·Éî·Éë·Éò·É° ID ·Éê·É† ·Éê·É†·Éò·É°', 'error');
      return;
    }

    this.isSending = true;
    this.stopTyping();
    
    const messageData = {
      receiverId: receiverId,
      content: messageContent
    };

    console.log('üì§ Sending message:', messageData);

    this.messageService
      .sendMessage(messageData)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (response) => {
          console.log('‚úÖ Message sent successfully:', response);
          
          if (response.success && response.data) {
            const newMsg = response.data;
            const messageId = newMsg._id || newMsg.id;
            
            // Check if already exists
            const exists = this.messages.some(m => 
              ((m._id || m.id) === messageId)
            );
            
            if (!exists) {
              console.log('‚ûï Adding sent message to UI');
              this.messages.push(newMsg);
              
              // ‚úÖ Force UI update
              this.cdr.detectChanges();
              this.shouldScrollToBottom = true;
            }
            
            this.newMessage = '';
          }
          
          this.isSending = false;
        },
        error: (error) => {
          console.error('‚ùå Failed to send message:', error);
          this.isSending = false;
          this.showSnackBar('·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éò·É° ·Éí·Éê·Éí·Éñ·Éê·Éï·Éú·Éê ·Éï·Éî·É† ·Éõ·Éù·ÉÆ·Éî·É†·ÉÆ·Éì·Éê', 'error');
        }
      });
  }

  onKeyPress(event: KeyboardEvent): void {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      this.sendMessage();
    }
  }

  onMessageInput(): void {
    const otherUserId = this.extractUserId(this.selectedConversation?.otherUser);
    if (!otherUserId) return;
    
    this.socketService.emitTypingStart(this.data.userId, otherUserId);
    
    if (this.typingTimeout) {
      clearTimeout(this.typingTimeout);
    }
    
    this.typingTimeout = setTimeout(() => {
      this.stopTyping();
    }, 2000);
  }

  private stopTyping(): void {
    const otherUserId = this.extractUserId(this.selectedConversation?.otherUser);
    if (!otherUserId) return;
    
    this.socketService.emitTypingStop(this.data.userId, otherUserId);
    
    if (this.typingTimeout) {
      clearTimeout(this.typingTimeout);
      this.typingTimeout = null;
    }
  }

  scrollToBottom(): void {
    try {
      const container = document.querySelector('.messages-list-container');
      if (container) {
        container.scrollTop = container.scrollHeight;
        console.log('üìú Scrolled to bottom');
      }
    } catch (err) {
      console.error('‚ùå Scroll error:', err);
    }
  }

  getMessageTime(message: Message): string {
    const date = new Date(message.createdAt);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return '·Éê·ÉÆ·Éö·Éê·ÉÆ·Éê·Éú';
    if (diffMins < 60) return `${diffMins} ·É¨·Éó`;
    if (diffHours < 24) return `${diffHours} ·É°·Éó`;
    if (diffDays < 7) return `${diffDays} ·Éì·É¶·Éî`;
    
    return date.toLocaleDateString('ka-GE', {
      day: 'numeric',
      month: 'short'
    });
  }

  getLastMessageTime(conversation: Conversation): string {
    if (!conversation.lastMessage) return '';
    return this.getMessageTime(conversation.lastMessage);
  }

  getLastMessagePreview(conversation: Conversation): string {
    if (!conversation.lastMessage) return '·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò ·Éê·É† ·Éê·É†·Éò·É°';
    
    const content = conversation.lastMessage.content || '';
    if (!content.trim()) return '·Éê·ÉÆ·Éê·Éö·Éò ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éê';
    
    return content.length > 40 ? content.substring(0, 40) + '...' : content;
  }

  isOwnMessage(message: Message): boolean {
    const msgSenderId = this.extractUserId(message.senderId);
    return msgSenderId === this.data.userId;
  }

  deleteConversation(conversation: Conversation, event: Event): void {
    event.stopPropagation();
    
    if (!confirm('·Éú·Éê·Éõ·Éì·Éï·Éò·Éö·Éê·Éì ·Éí·É°·É£·É†·Éó ·É°·Éê·É£·Éë·É†·Éò·É° ·É¨·Éê·É®·Éö·Éê?')) {
      return;
    }

    const conversationId = conversation._id || conversation.id;
    if (!conversationId) return;

    this.messageService.deleteConversation(conversationId).subscribe({
      next: () => {
        console.log('‚úÖ Conversation deleted');
        this.showSnackBar('·É°·Éê·É£·Éë·Éê·É†·Éò ·É¨·Éê·É®·Éö·Éò·Éö·Éò·Éê', 'success');
        
        this.conversations = this.conversations.filter(c => 
          (c._id || c.id) !== conversationId
        );
        
        if (this.selectedConversation && 
            (this.selectedConversation._id === conversationId || 
             this.selectedConversation.id === conversationId)) {
          this.selectedConversation = null;
          this.messages = [];
        }
        
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('‚ùå Failed to delete conversation:', error);
        this.showSnackBar('·É°·Éê·É£·Éë·É†·Éò·É° ·É¨·Éê·É®·Éö·Éê ·Éï·Éî·É† ·Éõ·Éù·ÉÆ·Éî·É†·ÉÆ·Éì·Éê', 'error');
      }
    });
  }

  close(): void {
    this.dialogRef.close();
  }

  showSnackBar(message: string, type: 'success' | 'error' = 'error'): void {
    this.snackBar.open(message, '·Éì·Éê·ÉÆ·É£·É†·Éï·Éê', {
      duration: 3000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom',
      panelClass: type === 'success' ? 'snackbar-success' : 'snackbar-error'
    });
  }
  
  getDefaultAvatar(): string {
    return this.profileImageService.getDefaultAvatar();
  }
}